{
  "devops": [
    {
      "id": 1,
      "type": 1,
      "name": "Scraping Merge Hell",
      "description": "Your team runs automated checks on any pull request* into trunk*. Nothing gets merged without passing the checks! This practice keeps the repository stable and helps reviewers catch bugs early! *Pull requests or merge requests: the practice of making your code available for review before submitting it into a project. *Trunk or main: in version control, this is the branch that contains reviewed and approved code; it constitutes the source of truth of your application"
    },
    {
      "id": 2,
      "type": 1,
      "name": "Multitasking Makes You Stupid",
      "description": "Limit how much work in progress is allowed! Is there something blocking a task? Identify and address the blocker before starting another task, or finish what you've started before taking on a new task."
    },
    {
      "id": 3,
      "type": 1,
      "name": "Environments a la Carte",
      "description": "The Development team has a number of self-service tools that allow it to create production-like environments on-demand. These tools allow developers to run the software in their own machines to get immediate feedback on how their code would behave in production without having to actually deploy it. Scaling issues? They can also easily spin up new machines without worrying about dependencies! Tools that allow you to do this include: containers, virtual machines, infrastructure as code, etc."
    },
    {
      "id": 4,
      "type": 1,
      "name": "Dark Launches",
      "description": "This practice is the deployment of features to production, while not making them accessible to users right away. Instead, users are enabled progressively or in groups. This practice allows developers to do A/B testing* of new features or designs against real users. *A/B testing: a user experience research methodology used for evaluating two hypothesis against different user groups and evaluate which one was more successful given some predefined metrics."
    },
    {
      "id": 5,
      "type": 1,
      "name": "Put the Pieces Together",
      "description": "It's best to check if your feature even works! Luckily, your team has the habit of writing integration tests for each feature. After all, you should check that all your classes and modules interact with each other as expected. Build your feature, create a few cases, and test it from end-to-end!"
    },
    {
      "id": 6,
      "type": 1,
      "name": "Feature Toggles",
      "description": "You can implement feature toggles by wrapping application logic or user interface elements with a conditional statement. This approach allows developers to turn on/off individual features if they break, if dependencies are not yet ready or if they are tied to a particular release date."
    },
    {
      "id": 7,
      "type": 1,
      "name": "Canary Release Pattern",
      "description": "In this pattern, you can run multiple stages of the production environment. Software gets rolled out first to a subset of users (your Canaries*) and then progressively to the rest. If something goes wrong in this first subset, you can roll the software version back. Otherwise, you roll it out to the next production environment. This pattern allows minimizing the impact of your release, your canaries can be internal users, testers, or any lower impact production stage."
    },
    {
      "id": 8,
      "type": 1,
      "name": "Fix Version",
      "description": "Libraries are often updated. As they should! But, an updated dependency could break your application. To avoid surprises, pin the version of your dependencies. This will allow you to keep a stable working version of your code and will give you time to check the new behavior of updated libraries (e.g., package.lock, poetry, debian distributions, etc.)."
    },
    {
      "id": 9,
      "type": 1,
      "name": "Build Automation",
      "description": "The process of fetching code, compiling it, and packaging it in an automated manner can be achieved via scripts, continuous integration, and delivery tools, among others. Build automation allows software to be compiled and packaged in a consistent way, avoiding errors that may be introduced manually, such as building against the wrong branch, wrong libraries, missing configuration files, etc."
    },
    {
      "id": 10,
      "type": 1,
      "name": "Catch Me If You Can",
      "description": "You just merged the last code changes for a new feature and automated testing passed. Why wait or deploy manually? Deploy it straight away! Continuous deployment allows you to automatically release your code changes into the production environment, making it available to users. Automated deployments can be configured to suit your deployment schedule and stages, minimizing impact and allowing time for testing."
    },
    {
      "id": 11,
      "type": 1,
      "name": "Blue-Green Deployment Pattern",
      "description": "In this pattern, you have two production environments - the blue one and the green one. The new version of your code gets deployed to one of them and user traffic is migrated progressively. This approach allows for both testing in the production environment and easy rollback with no downtime."
    },
    {
      "id": 12,
      "type": 1,
      "name": "Remove the Manual Bottleneck",
      "description": "Whenever you have any product, you should check if it is working properly every now and then. But why bother running the code by hand? Just automate it! Write some scripts that interact with your programmatic interfaces. Let this be a service request, a class' new method, or a new library function."
    },
    {
      "id": 13,
      "type": 1,
      "name": "Alarm! Alarm!",
      "description": "If a production issue arises that cannot be fixed within the allotted time, don't hesitate to 'pull the Andon Cord' - that is, ring the alarm and get all hands on deck! Developed in the '90s by Toyota, this process involved a physical cord that followed the assembly line in the production facility. When a serious issue occurs, any team member has the right to halt the production line and get the attention of the entire team until the issue is resolved, so production can resume."
    },
    {
      "id": 14,
      "type": 1,
      "name": "Divide and Conquer",
      "description": "When working on a feature try to divide into smaller pieces of work. Submitting big code changes infrequently makes reviewing the code a nightmare and makes it more difficult to stay on top of everyone else' changes. Smaller and more frequent code changes enable developers to work together on bigger pieces of work and keep pull requests* smaller and easier to review. *Pull requests or merge requests: the practice of making your code available for review before submitting it into a project."
    },
    {
      "id": 15,
      "type": 1,
      "name": "Leave the Formatting for the Linter",
      "description": "Style checking and linting* whenever a pull request* is opened allows reviewers to focus on the implementation. It also forces developers to use the same format, thereby minimizing the differences displayed in the pull request. *Linting: the automated checking of source code for programmatic and stylistic errors. *Pull requests or merge requests: the practice of making your code available for review before submitting it into a project."
    },
    {
      "id": 16,
      "type": 1,
      "name": "Immutable Infrastructure",
      "description": "Any changes to a production environment should first go through version control, and the environment should be re-created from scratch. This allows for easy recovery or generation of new machines."
    },
    {
      "id": 17,
      "type": 1,
      "name": "Code Analyzer",
      "description": "Run static code analysis on commits whenever a pull request* is opened. Just remember that reviewers are your colleagues! Spare some time and check your pull request before asking them to review it. Static analysis* is often used to uncover security vulnerabilities, performance issues, non-compliance with standards, use of out-of-date constructs, etc. *Static Analysis: automated analysis of code without executing the application vs. Dynamic Analysis which tests and analyses code at execution. *Pull requests or merge requests: the practice of making your code available for review before submitting it into a project."
    },
    {
      "id": 18,
      "type": 1,
      "name": "Make the Work Visible",
      "description": "Your team uses visual boards (e.g., kanban) or sprint planning boards to keep track of ongoing items. These enable your team to track which items belong to the current sprint, including their sizing, description, acceptance criteria, ownership, and status, among other things. *Kanban: a visual system used to manage and keep track of work as it moves through a process. *Sprint: a short period of time in which a team works to complete specific tasks, often breaking the project into digestible blocks."
    },
    {
      "id": 19,
      "type": 2,
      "name": "Big Brother Infrastructure",
      "description": "Centralized telemetry* infrastructure enables you to add logs at different levels - by application, business, or environment - so you can get metrics on failures, usage, traffic, etc. *telemetry: the process of gathering performance or health data of any product or application."
    },
    {
      "id": 20,
      "type": 2,
      "name": "Meaningful Logs",
      "description": "Developers must choose log level appropriately:'debug' for more detailed information, 'info' for user drive actions. 'warn' for potential errors, and 'error' for application level errors. Of course, you can easily change the log level for your application. This way, you can get sufficient information to defect potential issues without wasting valuable disk space!"
    },
    {
      "id": 21,
      "type": 2,
      "name": "One of these things is not like the other",
      "description": "Analyze your logs to identify unexpected behavior. By defining expected behavior, you can find anomalies (e.g., 1,000 failed login attempts in less than a minute). Anomaly detection could also help you identify where in your system resources are being overloaded, thus preventing delays or issues in the processing of user requests."
    },
    {
      "id": 22,
      "type": 2,
      "name": "Easy Peasy",
      "description": "Adding relevant logs should be as easy as making a one-line code change. For example, your authentication library provides the method logSuccessfulAuthentication(...). This allows for consistency and to easily record important - and repetitive events. Later on, you can even get usage stats!"
    },
    {
      "id": 23,
      "type": 2,
      "name": "No Surprises",
      "description": "Anyone who wants to see metrics on how your service is running should be able to access the data easily. You have an easily accessible website that displays metrics on traffic, deployments, test results, etc., for anyone on the team to review."
    },
    {
      "id": 24,
      "type": 2,
      "name": "Full-Stack Telemetry Coverage",
      "description": "You have telemetry set up for your entire stack: front-end, back-end, infrastructure, build, and deployment, etc. When debugging an issue, you can easily identify which part(s) of your stack had problems (e.g., was it the network, a library upgrade, or a feature flag?)."
    },
    {
      "id": 25,
      "type": 2,
      "name": "Measure your Infrastructure",
      "description": "You have tools set up (e.g., dashboards, alarms, etc.) to observe the status of your infrastructure as a whole. This means that in a system of services that communicate with each other, whenever there's an issue, it's quick and easy to identify which service is impacted."
    },
    {
      "id": 26,
      "type": 2,
      "name": "Better Safe than Sorry",
      "description": "Integrate security into every step of the development, delivery, and deployment process. You can use automated security checks for known vulnerabilities when submitting your code. This allows you to catch vulnerabilities early without compromising your systems or the user's data."
    },
    {
      "id": 27,
      "type": 2,
      "name": "Goodbye Darkness My Old Friend",
      "description": "You have dashboards in place to help you identify long processing requests, high traffic times, and the most-used service calls. This enables you to anticipate issues, work on improvements, or debug faster!"
    },
    {
      "id": 28,
      "type": 3,
      "name": "Go Beyond the Chat Room",
      "description": "Many organizations use chat rooms to facilitate collaboration, transparency, and knowledge-sharing. You can also use chat bots to automate processes and capture organizational knowledge. For example, events such as code commits or production deployments can automatically emit status updates for everyone to see! Or the chatbot can respond with a link to a library's documentation or answers to frequently asked questions for quick and easy access."
    },
    {
      "id": 29,
      "type": 3,
      "name": "Blame is Stupid",
      "description": "After a major incident has been resolved. hold a post-mortem meeting to discuss what happened, why, and how to avoid having it happen again in the future. Do not point fingers! This practice allows everyone to learn, prevents the incident from occurring again, and helps enable a just culture."
    },
    {
      "id": 30,
      "type": 3,
      "name": "Master of Disaster",
      "description": "Institute days to rehearse for BIG failures. Schedule a 'future catastrophic event', and give teams time to prepare, eliminate all single points of failure, and create any necessary procedures. This tabletop exercise will expose latent defects and prepare your people for when real problems occur."
    },
    {
      "id": 31,
      "type": 3,
      "name": "Be a Builder, not a Bricklayer",
      "description": "The codification of standards and processes which encompass the sum of the company's organizational knowledge should be automated in an executable form that makes it easy to reuse. Consider putting this knowledge in a centralized source code repository or creating a shared service that everyone can use."
    },
    {
      "id": 32,
      "type": 3,
      "name": "Single Source of Truth",
      "description": "Having a means to maintain good versions of libraries and dependencies is imperative and will reduce operational burden and stress. This could be achieved by using a firm-wide, shared source code repository or a package management system. When a shared library is updated, it propagates to every other service that uses it, an approach that is integrated throughout each team's deployment pipeline."
    },
    {
      "id": 33,
      "type": 3,
      "name": "Ignorance Is NOT Bliss",
      "description": "Share libraries and documentation! Enable everyone to share their work and knowledge. Provide platforms to share knowledge via internal forums, wikis, and search engines. It should also be easy to publish information to be shared!"
    },
    {
      "id": 34,
      "type": 3,
      "name": "Chaos is a Ladder",
      "description": "Inject chaos! Break things in a controlled environment to see how your system reacts. Chaos testing randomizes breakages to help find unpredictable bugs. Not only does this approach keep Engineering teams on their toes, but also will make your organization and its systems more resilient!"
    },
    {
      "id": 35,
      "type": 3,
      "name": "Share widely your learnings from Mistakes",
      "description": "Document post-mortem* meetings and make this information available to everyone. You want to prevent anyone else from repeating the same mistake or getting blocked by a similar issue. *Post-mortem: the process of reviewing an incident, identifying what happened, and what can be done better to prevent it from reoccurring in the future."
    },
    {
      "id": 36,
      "type": 3,
      "name": "Raise the Bar",
      "description": "Once your error detection practices have become a habit, start looking to prevent issues, instead of just fixing them. Get into the mindframe of thinking about potential issues from the outset - before they become a reality. This will save time by preventing the team from putting out fires down the line."
    }
  ]
}
